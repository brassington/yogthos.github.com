<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>noir.util.middleware documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Lib-noir 0.6.6 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="noir.cookies.html"><span>noir.cookies</span></a></li><li><a href="noir.io.html"><span>noir.io</span></a></li><li><a href="noir.request.html"><span>noir.request</span></a></li><li><a href="noir.response.html"><span>noir.response</span></a></li><li><a href="noir.session.html"><span>noir.session</span></a></li><li><a href="noir.util.cache.html"><span>noir.util.cache</span></a></li><li><a href="noir.util.crypt.html"><span>noir.util.crypt</span></a></li><li class="current"><a href="noir.util.middleware.html"><span>noir.util.middleware</span></a></li><li><a href="noir.util.route.html"><span>noir.util.route</span></a></li><li><a href="noir.util.test.html"><span>noir.util.test</span></a></li><li><a href="noir.validation.html"><span>noir.validation</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="noir.util.middleware.html#var-app-handler"><span>app-handler</span></a></li><li><a href="noir.util.middleware.html#var-war-handler"><span>war-handler</span></a></li><li><a href="noir.util.middleware.html#var-wrap-access-rules"><span>wrap-access-rules</span></a></li><li><a href="noir.util.middleware.html#var-wrap-canonical-host"><span>wrap-canonical-host</span></a></li><li><a href="noir.util.middleware.html#var-wrap-force-ssl"><span>wrap-force-ssl</span></a></li><li><a href="noir.util.middleware.html#var-wrap-rewrites"><span>wrap-rewrites</span></a></li><li><a href="noir.util.middleware.html#var-wrap-strip-trailing-slash"><span>wrap-strip-trailing-slash</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>noir.util.middleware documentation</h2><pre class="doc"></pre><div class="public" id="var-app-handler"><h3>app-handler</h3><div class="usage"><code>(app-handler app-routes &amp; {:keys [store multipart middleware access-rules]})</code></div><pre class="doc">creates the handler for the application and wraps it in base middleware:
- wrap-request-map
- api
- wrap-multipart-params
- wrap-noir-validation
- wrap-noir-cookies
- wrap-noir-flash
- wrap-noir-session

:store - optional session store, defaults to memory store
:multipart - an optional map of multipart-params middleware options
:middleware - a vector of any custom middleware wrappers you wish to supply
:access-rules - a vector of access rules you wish to supply,
                each rule should a function or a rule map as specified in wrap-access-rules, eg:

                :access-rules [rule1
                               rule2
                               {:redirect &quot;/unauthorized1&quot;
                                :rules [rule3 rule4]}]</pre></div><div class="public" id="var-war-handler"><h3>war-handler</h3><div class="usage"><code>(war-handler app-handler)</code></div><pre class="doc">wraps the app-handler in middleware needed for WAR deployment:
- wrap-resource
- wrap-file-info
- wrap-base-url</pre></div><div class="public" id="var-wrap-access-rules"><h3>wrap-access-rules</h3><div class="usage"><code>(wrap-access-rules handler rules)</code></div><pre class="doc">wraps the handler with the supplied access rules.

Use the noir.util.route/restricted macro to wrap any routes
that you wish the access rules to apply to, eg:

(GET &quot;/user/profile&quot; [] (restricted &quot;this route is private&quot;))

Each rule accepts the request and returns a boolean indicating whether it
passed or not, eg:

(defn user-access [req]
 (session/get :user))
   
(wrap-access-rules handler [user-access])

Each rule can either be a function or a map. When a rule is a function, then
it redirects to &quot;/&quot; and will be checked for each restricted route.

When specifying rules as a map you can provide further directives using the
following keys:

:uri - the URI pattern to which the rules apply (optional, defaults to any URI)
:uris - alternative to :uri, allows specifying a collection of URIs (optional)
:redirect - the redirect target for the rules (optional defaults to &quot;/&quot;)
:on-fail - alternative to redirect, allows specifying a handler function for
           handling the failure, the function must accept the request as a
           parameter (optional)
:rule - a single rule (either :rule or :rules is required)
:rules - alternative to rule, allows specifying a list of rules

The :rules can be specified in any of the following ways:

:rules [rule1 rule2]
:rules {:any [rule1 rule2]}
:rules {:every [rule1 rule2] :any [rule3 rule4]}            

By default every rule has to pass, the :any key specifies that it's sufficient for
any of the rules to pass. 

(defn admin-access [req]
 (session/get :admin))

(wrap-access-rules handler [{:redirect &quot;/access-denied&quot;
                             :rule user-access}])

(wrap-access-rules handler [{:uri &quot;/user/*&quot; :rule user-access}])

(wrap-access-rules handler [{:uri &quot;/admin/*&quot; :rule admin-access}
                            {:uri &quot;/user/*&quot; 
                             :rules {:any [user-access admin-access]}])

(wrap-access-rules handler [{:on-fail (fn [req] &quot;access restricted&quot;)
                             :rule user-access}])   
</pre></div><div class="public" id="var-wrap-canonical-host"><h3>wrap-canonical-host</h3><div class="usage"><code>(wrap-canonical-host app canonical)</code></div><pre class="doc">If the request is not targeting host canonical, redirect the
request to that host.</pre></div><div class="public" id="var-wrap-force-ssl"><h3>wrap-force-ssl</h3><div class="usage"><code>(wrap-force-ssl app)</code></div><pre class="doc">If the request's scheme is not https, redirect with https.
Also checks the X-Forwarded-Proto header.</pre></div><div class="public" id="var-wrap-rewrites"><h3>wrap-rewrites</h3><div class="usage"><code>(wrap-rewrites handler &amp; rewrites)</code></div><pre class="doc">Rewrites should be [regex replacement] pairs. The first regex that matches the request's URI will
have the corresponding (global) replacement performed before calling the wrapped handler.</pre></div><div class="public" id="var-wrap-strip-trailing-slash"><h3>wrap-strip-trailing-slash</h3><div class="usage"><code>(wrap-strip-trailing-slash handler)</code></div><pre class="doc">If the requested url has a trailing slash, remove it.
</pre></div></div></body></html>