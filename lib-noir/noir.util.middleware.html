<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>noir.util.middleware documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Lib-noir 0.6.1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="noir.cookies.html"><span>noir.cookies</span></a></li><li><a href="noir.io.html"><span>noir.io</span></a></li><li><a href="noir.request.html"><span>noir.request</span></a></li><li><a href="noir.response.html"><span>noir.response</span></a></li><li><a href="noir.session.html"><span>noir.session</span></a></li><li><a href="noir.util.cache.html"><span>noir.util.cache</span></a></li><li><a href="noir.util.crypt.html"><span>noir.util.crypt</span></a></li><li class="current"><a href="noir.util.middleware.html"><span>noir.util.middleware</span></a></li><li><a href="noir.util.route.html"><span>noir.util.route</span></a></li><li><a href="noir.validation.html"><span>noir.validation</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="noir.util.middleware.html#var-app-handler"><span>app-handler</span></a></li><li><a href="noir.util.middleware.html#var-war-handler"><span>war-handler</span></a></li><li><a href="noir.util.middleware.html#var-wrap-access-rules"><span>wrap-access-rules</span></a></li><li><a href="noir.util.middleware.html#var-wrap-canonical-host"><span>wrap-canonical-host</span></a></li><li><a href="noir.util.middleware.html#var-wrap-force-ssl"><span>wrap-force-ssl</span></a></li><li><a href="noir.util.middleware.html#var-wrap-rewrites"><span>wrap-rewrites</span></a></li><li><a href="noir.util.middleware.html#var-wrap-strip-trailing-slash"><span>wrap-strip-trailing-slash</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>noir.util.middleware documentation</h2><pre class="doc"></pre><div class="public" id="var-app-handler"><h3>app-handler</h3><div class="usage"><code>(app-handler app-routes &amp; {:keys [store multipart middleware access-rules]})</code></div><pre class="doc">creates the handler for the application and wraps it in base middleware:
- wrap-request-map
- api
- wrap-multipart-params
- wrap-noir-validation
- wrap-noir-cookies
- wrap-noir-flash
- wrap-noir-session

:store - optional session store, defaults to memory store
:multipart - an optional map of multipart-params middleware options
:middleware - a vector of any custom middleware wrappers you wish to supply
:access-rules - a vector of access rules you wish to supply,
                each rule should a function or a rule map as specified in wrap-access-rules, eg:

                :access-rules [rule1
                               rule2
                               {:redirect &quot;/unauthorized1&quot;
                                :rules [rule3 rule4]}]</pre></div><div class="public" id="var-war-handler"><h3>war-handler</h3><div class="usage"><code>(war-handler app-handler)</code></div><pre class="doc">wraps the app-handler in middleware needed for WAR deployment:
- wrap-resource
- wrap-file-info
- wrap-base-url</pre></div><div class="public" id="var-wrap-access-rules"><h3>wrap-access-rules</h3><div class="usage"><code>(wrap-access-rules handler rules)</code></div><pre class="doc">wraps the handler with the supplied access rules, each rule accepts
the request and returns a boolean indicating whether it passed or not, eg:

(defn private-pages [req]
 (and (some #{(:uri req)} [&quot;/private-page1&quot; &quot;/private-page2&quot;]) 
      (session/get :user)))

by default if none of the rules return true the client will be redirected
to /. It's possible to pass a custom redirect target by specifying the 
:redirect key pointing to a URI.

The value of the :redirect key can either be a string or a function that
takes the request as its argument.

The rules can be supplied either as a function or a map indicating the
redirect target and the rules that redirect to that target, eg:

(wrap-access-rules handler some-rule
                           another-rule                              
                           {:redirect &quot;/unauthorized&quot;
                            :rules [rule3 rule4]}
                           {:redirect (fn [req] (println \&quot;redirecting\&quot;)
                                        \&quot;/unauthorized\&quot;)
                            :rules [rule5]})

the first set of rules that fails will cause a redirect to its redirect target</pre></div><div class="public" id="var-wrap-canonical-host"><h3>wrap-canonical-host</h3><div class="usage"><code>(wrap-canonical-host app canonical)</code></div><pre class="doc">If the request is not targeting host canonical, redirect the
request to that host.</pre></div><div class="public" id="var-wrap-force-ssl"><h3>wrap-force-ssl</h3><div class="usage"><code>(wrap-force-ssl app)</code></div><pre class="doc">If the request's scheme is not https, redirect with https.
Also checks the X-Forwarded-Proto header.</pre></div><div class="public" id="var-wrap-rewrites"><h3>wrap-rewrites</h3><div class="usage"><code>(wrap-rewrites handler &amp; rewrites)</code></div><pre class="doc">Rewrites should be [regex replacement] pairs. The first regex that matches the request's URI will
have the corresponding (global) replacement performed before calling the wrapped handler.</pre></div><div class="public" id="var-wrap-strip-trailing-slash"><h3>wrap-strip-trailing-slash</h3><div class="usage"><code>(wrap-strip-trailing-slash handler)</code></div><pre class="doc">If the requested url has a trailing slash, remove it.
</pre></div></div></body></html>